<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Implementing a workflow graph | Teraku's blog</title><meta name=keywords content="rust,workflow,graph,flowty"><meta name=description content="Implement a struct which holds the workflow graph and yields the next values in line for execution."><meta name=author content="Teraku"><link rel=canonical href=https://teraku.de/posts/workflow-graph-implementation/><link href=/assets/css/stylesheet.min.d5d820de85dae34a78c22303e07aa685bb90ec25a056c702c0b1a964ca68861d.css integrity="sha256-1dgg3oXa40p4wiMD4HqmhbuQ7CWgVscCwLGpZMpohh0=" rel="preload stylesheet" as=style><link rel=icon href=https://teraku.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://teraku.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://teraku.de/favicon-32x32.png><link rel=apple-touch-icon href=https://teraku.de/apple-touch-icon.png><link rel=mask-icon href=https://teraku.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-123-45','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Implementing a workflow graph"><meta property="og:description" content="Implement a struct which holds the workflow graph and yields the next values in line for execution."><meta property="og:type" content="article"><meta property="og:url" content="https://teraku.de/posts/workflow-graph-implementation/"><meta property="article:published_time" content="2020-07-19T09:06:08+02:00"><meta property="article:modified_time" content="2020-07-19T09:06:08+02:00"><meta property="og:site_name" content="Teraku's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing a workflow graph"><meta name=twitter:description content="Implement a struct which holds the workflow graph and yields the next values in line for execution."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Implementing a workflow graph","name":"Implementing a workflow graph","description":"Goal Implement a struct which holds the workflow graph and yields the next values in line for execution.\nWorkflow Graph When writing a workflow management engine, one has to decide ‚Ä¶","keywords":["rust","workflow","graph","flowty"],"articleBody":"Goal Implement a struct which holds the workflow graph and yields the next values in line for execution.\nWorkflow Graph When writing a workflow management engine, one has to decide on the data structure of the workflow. I decided to go for the most common one: A directed acyclic graph, in short DAG. I thought about using a more open type, i. e. a cyclic graph, but that has really weird implications for a retry system and output handling. It would be a cool idea to explore, but it sounds like a pain to implement.\nI have not yet written anything about OpenWorkflow, but will be using the types here. Most of them should be self-explanatory, and I‚Äôm sure there will be posts about OpenWorkflow eventually, but if you‚Äôre interested just check out the protobuf definition in the linked repository.\nImplementing a DAG Luckily for me, there is a very extensive graph library in rust, petgraph. So first of I need to create the graph to hold my task instances.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  usechrono::Duration;usepetgraph::Graph;useopenworkflow::{Execution,RunCondition,ExecutionStatus,Task};#[derive(PartialEq, Clone)]pubstruct TaskInstance{task_id: String,retries: u32,max_retries: u32,retry_interval: Duration,execution_details: Execution,execution_status: OptionExecutionStatus,run_condition: RunCondition,downstream_tasks: VecString,}type Node=TaskInstance;type Edge=RunCondition;pubstruct Dag{graph: Graph::Node,Edge,}  And then a way to fill my Dag with a list of tasks, parsed from a protobuf message. For this Dag implements the TryFrom trait.\n1 2 3 4 5 6 7 8  usestd::convert::TryFrom;implTryFromVecTaskforDag{type Error=FlowtyError;fn try_from(tasks: \u0026VecTask)- ResultDag,Self::Error{// deducted \\\\ }  FlowtyError is using SNAFU to create errors for Flowty.\n1 2 3 4 5 6 7 8 9 10  usesnafu::Snafu;#[derive(Debug, Snafu)]pubenum FlowtyError{// deducted \\\\ #[snafu(display(\"Failed to parse DAG\"))]ParsingError,#[snafu(display(\"Cyclic dependency detected!\"))]CyclicDependencyError,}  Now that that‚Äôs out of the way, let‚Äôs populate the graph. First we plainly create it and iterate over our list of tasks.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  letmutgraph=Graph::Node,Edge::new();fortaskintasks{iftask.execution.is_none(){returnErr(FlowtyError::ParsingError);}letretry_interval=Duration::from_std(task.retry_interval.clone().unwrap_or_default().try_into().unwrap_or_default()).unwrap();letti=TaskInstance{task_id: task.task_id.clone(),retries: 0,max_retries: task.retries,retry_interval,execution_details: task.execution.clone().unwrap(),execution_status: None,run_condition: RunCondition::from(task.condition),downstream_tasks: task.downstream_tasks.clone(),};graph.add_node(ti);}  Parsing from a prost_types::Duration to a chrono::Duration is a bit of a pain, going over the std::time::Duration type, but it is what it is. Now we have a graph full of nodes, but no edges. To change that we iterate through all node indices and check their downstream dependencies.\n1 2 3 4 5 6 7 8 9 10 11  forparent_indexingraph.node_indices(){letti=\u0026graph[parent_index].clone();fordownstream_taskin\u0026ti.downstream_tasks{matchgraph.node_indices().find(|i|graph[*i].task_id==*downstream_task){Some(child_index)={graph.update_edge(parent_index,child_index,graph[child_index].run_condition);},None=()};}}  We add an edge of the task_id if a downstream task is matching a node in our graph. Any typos and so on in that list of downstream will, for now, just be ignored. Now we have a directed graph, since that is the petgraph default. Before returning let‚Äôs check if it‚Äôs acyclic.\n1 2 3  ifalgo::is_cyclic_directed(\u0026graph){returnErr(FlowtyError::CyclicDependencyError);}  Nice! Petgraph comes with a built-in functionality. Now our Dag is complete.\n1  Ok(Dag{graph})  Traversing (or, getting the current execution stage) So now comes the part you‚Äôve been waiting for: Traversing. Or rather, getting the current execution stage.\nYou see, it‚Äôs not so much that I want to drain my graph when passing nodes, nor that I want to get to the end of it immediatly. Instead, I want to know which nodes (tasks) are executing, or are up for execution. Which is why Dag also implements Iterator. An iterator allows to ask for the next item in line. It‚Äôs a bit of an abuse of the functionality, because using this iterator in a for loop will block the entire thead until the graph is completly done. But calling next whenever we want to know if action is required on the Dag is handy.\nLet‚Äôs start from the top. Namely using a topologic sort (thanks petgraph) to visit each node in the correct order.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  implIteratorforDag{type Item=VecNodeIndex;/// Traverse the Dag via the Iterator. /// Returns the current execution stage of the Dag. Meaning all TaskInstances which are currently executing or /// ready for execution. /// /// Uses toposort to start from the top, then checks if a task's run_condition is met. /// Whenever a task is added to the current stage, it's downstream tasks are saved. /// If a task does not appear in the saved downstream list, it's immediatly added to the stage. /// If a task is inside the downstream list, its run_condition is checked. fn next(\u0026mutself)- OptionSelf::Item{letmutstage: Self::Item=Vec::new();letmutdownstream: VecString=Vec::new();fornodeinalgo::toposort(\u0026self.graph,None).unwrap(){iftask_instance_is_done(\u0026self.graph[node]){continue;}// deducted \\\\ }// deducted \\\\ }  It‚Äôs already explained in the comment above the function, but let‚Äôs write it out step-by-step. The toposort is already here, returning the index for each node in order. We also create what we will later return, the stage, and the list of downstream tasks of the tasks in the current stage. Additionally, I added a check at the very beginning of the loop, calling task_instance_is_done() which returns true if the status matches to success or failure. In that case this node is already a-okay‚úÖ.\nNow we check if the current task is already in the downstream vector. If it is not, we can directly add it to our stage because we get all results from toposort in order.\n1 2 3 4 5 6 7  letdownstream_tasks=\u0026self.graph[node].downstream_tasks;ifdownstream.contains(\u0026self.graph[node].task_id){// deducted \\\\ }else{stage.push(node);downstream.append(\u0026mutdownstream_tasks.clone());}  What‚Äôs missing now is the logic to determine whether something should be added to the current stage, even if it is part of the downstream dependencies. So let‚Äôs match over the run_condition of our node. The important conditions here are\n None, execute without caring for dependencies OneDone, execute when one parent is done OneSuccess, execute when one parent has succeeded OneFailed, execute when one parent has failed  The reason behind this is, that if all parents were done, it should not have been listed in the downstream vector in the first place. I implemented the logic for all possible cases in the match. Rust match is exhaustive, although I could‚Äôve probably just combined them all with _ = (). But I decided it would be nice to have, and I will most likely extend the features of this code later.\nFor now, let‚Äôs dive into the match, and match to None.\n1 2 3 4 5 6 7  matchself.graph[node].run_condition{RunCondition::None={stage.push(node);downstream.append(\u0026mutdownstream_tasks.clone());},// deducted \\\\ }  Simple enough, we push the current node to the stage and add its downstream_tasks to the downstream vector. Now the arms for OneDone OneSuccess OneFailed.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  matchself.graph[node].run_condition{RunCondition::None={stage.push(node);downstream.append(\u0026mutdownstream_tasks.clone());},RunCondition::OneDone={forparentinself.graph.neighbors_directed(node,Direction::Incoming){iftask_instance_is_done(\u0026self.graph[parent]){stage.push(node);downstream.append(\u0026mutdownstream_tasks.clone());break;}}},RunCondition::OneSuccess={forparentinself.graph.neighbors_directed(node,Direction::Incoming){ifmatches!(self.graph[parent].execution_status,Some(ExecutionStatus::Success)){stage.push(node);downstream.append(\u0026mutdownstream_tasks.clone());break;}}},RunCondition::OneFailed={forparentinself.graph.neighbors_directed(node,Direction::Incoming){ifmatches!(self.graph[parent].execution_status,Some(ExecutionStatus::Failed)){stage.push(node);downstream.append(\u0026mutdownstream_tasks.clone());break;}}},// deducted \\\\ }  I deducted the remaining conditions, because as I‚Äôve mentioned they are not really relevant as of yet. Basically the code for every arm is very similiar. We start of by iterating through the parents by using the neighbors_directed() functions with the Incoming direction. This means we get an Iterator of indices for the graph for all nodes with edges going towards our current node: the parents. Then we check if the parent‚Äôs execution status is meeting our run condition. If so, we add the node to the stage and its downstream_tasks to the downstream.\nSimple as that, we created the current execution stage. Finally, we return the result.\n1 2 3 4 5  ifstage.len()==0{None}else{Some(stage)}  By returning None when the vector is empty, we signal the end of the iterator.\nReview We achieved our goal of implementing a workflow graph, which yields the tasks which are executing or up for execution. Since I‚Äôm new to Rust I‚Äôm not sure if I‚Äôve taken the best or fanciest path, so I‚Äôm open for feedback. I‚Äôm also new to writing these kinds of posts, so feedback for this format is also appreciated.\nNow that we have a Dag which we can ask for the next tasks in line, I will spend some more time on the scheduler. The next post will thus most likely be about the workings of the scheduler and using this implemention of a Dag.\nAlso I might come back to this implementation to add more features, refactor with more feedback and knowledge and most definetly add some logging capabilitiesüìù.\n","wordCount":"1351","inLanguage":"en","datePublished":"2020-07-19T09:06:08+02:00","dateModified":"2020-07-19T09:06:08+02:00","author":{"@type":"Person","name":"Teraku"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://teraku.de/posts/workflow-graph-implementation/"},"publisher":{"@type":"Organization","name":"Teraku's blog","logo":{"@type":"ImageObject","url":"https://teraku.de/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://teraku.de accesskey=h title="Home (Alt + H)"><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://teraku.de/categories/ title=categories><span>categories</span></a></li><li><a href=https://teraku.de/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Implementing a workflow graph</h1><div class=post-description>Implement a struct which holds the workflow graph and yields the next values in line for execution.</div><div class=post-meta>July 19, 2020&nbsp;¬∑&nbsp;Teraku</div></header><div class=post-content><h2 id=goal>Goal<a hidden class=anchor aria-hidden=true href=#goal>#</a></h2><p>Implement a struct which holds the workflow graph and yields the next values in line for execution.</p><h2 id=workflow-graph>Workflow Graph<a hidden class=anchor aria-hidden=true href=#workflow-graph>#</a></h2><p>When writing a workflow management engine, one has to decide on the data structure of the workflow.
I decided to go for the most common one: A directed acyclic graph, in short DAG.
I thought about using a more open type, i. e. a cyclic graph, but that has really weird implications for a retry system and output handling.
It would be a cool idea to explore, but it sounds like a pain to implement.</p><p>I have not yet written anything about <a href=https://github.com/OpenWorkflow/OpenWorkflow>OpenWorkflow</a>, but will be using the types here.
Most of them should be self-explanatory, and I&rsquo;m sure there will be posts about OpenWorkflow eventually, but if you&rsquo;re interested just check out the protobuf definition in the linked repository.</p><h3 id=implementing-a-dag>Implementing a DAG<a hidden class=anchor aria-hidden=true href=#implementing-a-dag>#</a></h3><p>Luckily for me, there is a very extensive graph library in rust, <a href=https://github.com/petgraph/petgraph>petgraph</a>.
So first of I need to create the graph to hold my task instances.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>chrono</span>::<span class=n>Duration</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>petgraph</span>::<span class=n>Graph</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>openworkflow</span>::<span class=p>{</span><span class=n>Execution</span><span class=p>,</span><span class=w> </span><span class=n>RunCondition</span><span class=p>,</span><span class=w> </span><span class=n>ExecutionStatus</span><span class=p>,</span><span class=w> </span><span class=n>Task</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(PartialEq, Clone)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>TaskInstance</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=n>task_id</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>retries</span>: <span class=kt>u32</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>max_retries</span>: <span class=kt>u32</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>retry_interval</span>: <span class=nc>Duration</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>execution_details</span>: <span class=nc>Execution</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>execution_status</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=n>ExecutionStatus</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>run_condition</span>: <span class=nc>RunCondition</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>downstream_tasks</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>type</span> <span class=nc>Node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TaskInstance</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>type</span> <span class=nc>Edge</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>RunCondition</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Dag</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=n>graph</span>: <span class=nc>Graph</span>::<span class=o>&lt;</span><span class=n>Node</span><span class=p>,</span><span class=w> </span><span class=n>Edge</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>And then a way to fill my Dag with a list of tasks, parsed from a protobuf message.
For this <code>Dag</code> implements the <code>TryFrom</code> trait.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>convert</span>::<span class=n>TryFrom</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>TryFrom</span><span class=o>&lt;&amp;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Task</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Dag</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=k>type</span> <span class=nc>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>FlowtyError</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>	</span><span class=k>fn</span> <span class=nf>try_from</span><span class=p>(</span><span class=n>tasks</span>: <span class=kp>&amp;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Task</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>Dag</span><span class=p>,</span><span class=w> </span><span class=n>Self</span>::<span class=n>Error</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=c1>// deducted \\
</span><span class=c1></span><span class=w>	</span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p><code>FlowtyError</code> is using <a href=https://github.com/shepmaster/snafu>SNAFU</a> to create errors for Flowty.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>snafu</span>::<span class=n>Snafu</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug, Snafu)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>FlowtyError</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=c1>// deducted \\
</span><span class=c1></span><span class=w>	</span><span class=cp>#[snafu(display(</span><span class=s>&#34;Failed to parse DAG&#34;</span><span class=cp>))]</span><span class=w>
</span><span class=w>	</span><span class=n>ParsingError</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=cp>#[snafu(display(</span><span class=s>&#34;Cyclic dependency detected!&#34;</span><span class=cp>))]</span><span class=w>
</span><span class=w>	</span><span class=n>CyclicDependencyError</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>Now that that&rsquo;s out of the way, let&rsquo;s populate the graph.
First we plainly create it and iterate over our list of tasks.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>graph</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Graph</span>::<span class=o>&lt;</span><span class=n>Node</span><span class=p>,</span><span class=w> </span><span class=n>Edge</span><span class=o>&gt;</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=k>for</span><span class=w> </span><span class=n>task</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>tasks</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=n>task</span><span class=p>.</span><span class=n>execution</span><span class=p>.</span><span class=n>is_none</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>FlowtyError</span>::<span class=n>ParsingError</span><span class=p>);</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=n>retry_interval</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Duration</span>::<span class=n>from_std</span><span class=p>(</span><span class=w>
</span><span class=w>		</span><span class=n>task</span><span class=p>.</span><span class=n>retry_interval</span><span class=w>
</span><span class=w>		</span><span class=p>.</span><span class=n>clone</span><span class=p>()</span><span class=w>
</span><span class=w>		</span><span class=p>.</span><span class=n>unwrap_or_default</span><span class=p>()</span><span class=w>
</span><span class=w>		</span><span class=p>.</span><span class=n>try_into</span><span class=p>()</span><span class=w>
</span><span class=w>		</span><span class=p>.</span><span class=n>unwrap_or_default</span><span class=p>()</span><span class=w>
</span><span class=w>	</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=n>ti</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TaskInstance</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=n>task_id</span>: <span class=nc>task</span><span class=p>.</span><span class=n>task_id</span><span class=p>.</span><span class=n>clone</span><span class=p>(),</span><span class=w>
</span><span class=w>		</span><span class=n>retries</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>		</span><span class=n>max_retries</span>: <span class=nc>task</span><span class=p>.</span><span class=n>retries</span><span class=p>,</span><span class=w>
</span><span class=w>		</span><span class=n>retry_interval</span><span class=p>,</span><span class=w>
</span><span class=w>		</span><span class=n>execution_details</span>: <span class=nc>task</span><span class=p>.</span><span class=n>execution</span><span class=p>.</span><span class=n>clone</span><span class=p>().</span><span class=n>unwrap</span><span class=p>(),</span><span class=w>
</span><span class=w>		</span><span class=n>execution_status</span>: <span class=nb>None</span><span class=p>,</span><span class=w>
</span><span class=w>		</span><span class=n>run_condition</span>: <span class=nc>RunCondition</span>::<span class=n>from</span><span class=p>(</span><span class=n>task</span><span class=p>.</span><span class=n>condition</span><span class=p>),</span><span class=w>
</span><span class=w>		</span><span class=n>downstream_tasks</span>: <span class=nc>task</span><span class=p>.</span><span class=n>downstream_tasks</span><span class=p>.</span><span class=n>clone</span><span class=p>(),</span><span class=w>
</span><span class=w>	</span><span class=p>};</span><span class=w>
</span><span class=w>	</span><span class=n>graph</span><span class=p>.</span><span class=n>add_node</span><span class=p>(</span><span class=n>ti</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>Parsing from a <a href=https://docs.rs/prost-types/0.6.1/prost_types/struct.Duration.html><code>prost_types::Duration</code></a> to a <code>chrono::Duration</code> is a bit of a pain, going over the <code>std::time::Duration</code> type, but it is what it is.
Now we have a graph full of nodes, but no edges.
To change that we iterate through all node indices and check their downstream dependencies.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>for</span><span class=w> </span><span class=n>parent_index</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>graph</span><span class=p>.</span><span class=n>node_indices</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=n>ti</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>graph</span><span class=p>[</span><span class=n>parent_index</span><span class=p>].</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=n>downstream_task</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=o>&amp;</span><span class=n>ti</span><span class=p>.</span><span class=n>downstream_tasks</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>match</span><span class=w> </span><span class=n>graph</span><span class=p>.</span><span class=n>node_indices</span><span class=p>().</span><span class=n>find</span><span class=p>(</span><span class=o>|</span><span class=n>i</span><span class=o>|</span><span class=w> </span><span class=n>graph</span><span class=p>[</span><span class=o>*</span><span class=n>i</span><span class=p>].</span><span class=n>task_id</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=o>*</span><span class=n>downstream_task</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=nb>Some</span><span class=p>(</span><span class=n>child_index</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>				</span><span class=n>graph</span><span class=p>.</span><span class=n>update_edge</span><span class=p>(</span><span class=n>parent_index</span><span class=p>,</span><span class=w> </span><span class=n>child_index</span><span class=p>,</span><span class=w> </span><span class=n>graph</span><span class=p>[</span><span class=n>child_index</span><span class=p>].</span><span class=n>run_condition</span><span class=p>);</span><span class=w>
</span><span class=w>			</span><span class=p>},</span><span class=w>
</span><span class=w>			</span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>()</span><span class=w>
</span><span class=w>		</span><span class=p>};</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>We add an edge of the <code>task_id</code> if a downstream task is matching a node in our graph.
Any typos and so on in that list of downstream will, for now, just be ignored.
Now we have a directed graph, since that is the <code>petgraph</code> default.
Before returning let&rsquo;s check if it&rsquo;s acyclic.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>if</span><span class=w> </span><span class=n>algo</span>::<span class=n>is_cyclic_directed</span><span class=p>(</span><span class=o>&amp;</span><span class=n>graph</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>FlowtyError</span>::<span class=n>CyclicDependencyError</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>Nice! Petgraph comes with a built-in functionality. Now our Dag is complete.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=nb>Ok</span><span class=p>(</span><span class=n>Dag</span><span class=p>{</span><span class=n>graph</span><span class=p>})</span><span class=w>
</span></code></pre></td></tr></table></div></div><h3 id=traversing-or-getting-the-current-execution-stage>Traversing (or, getting the current execution stage)<a hidden class=anchor aria-hidden=true href=#traversing-or-getting-the-current-execution-stage>#</a></h3><p>So now comes the part you&rsquo;ve been waiting for: Traversing. Or rather, getting the current execution stage.</p><p>You see, it&rsquo;s not so much that I want to drain my graph when passing nodes, nor that I want to get to the end of it immediatly.
Instead, I want to know which nodes (tasks) are executing, or are up for execution.
Which is why <code>Dag</code> also <code>impl</code>ements <code>Iterator</code>.
An iterator allows to ask for the next item in line.
It&rsquo;s a bit of an abuse of the functionality, because using this iterator in a for loop will block the entire thead until the graph is completly done.
But calling <code>next</code> whenever we want to know if action is required on the Dag is handy.</p><p>Let&rsquo;s start from the top. Namely using a topologic sort (thanks <a href=https://docs.rs/petgraph/0.5.1/petgraph/algo/fn.toposort.html>petgraph</a>) to visit each node in the correct order.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Dag</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=k>type</span> <span class=nc>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>NodeIndex</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>	</span><span class=sd>/// Traverse the Dag via the Iterator.
</span><span class=sd></span><span class=w>	</span><span class=sd>/// Returns the current execution stage of the Dag. Meaning all TaskInstances which are currently executing or
</span><span class=sd></span><span class=w>	</span><span class=sd>/// ready for execution.
</span><span class=sd></span><span class=w>	</span><span class=sd>///
</span><span class=sd></span><span class=w>	</span><span class=sd>/// Uses toposort to start from the top, then checks if a task&#39;s run_condition is met.
</span><span class=sd></span><span class=w>	</span><span class=sd>/// Whenever a task is added to the current stage, it&#39;s downstream tasks are saved.
</span><span class=sd></span><span class=w>	</span><span class=sd>/// If a task does not appear in the saved downstream list, it&#39;s immediatly added to the stage.
</span><span class=sd></span><span class=w>	</span><span class=sd>/// If a task is inside the downstream list, its run_condition is checked.
</span><span class=sd></span><span class=w>	</span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>stage</span>: <span class=nc>Self</span>::<span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w>		</span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>downstream</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>algo</span>::<span class=n>toposort</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>graph</span><span class=p>,</span><span class=w> </span><span class=nb>None</span><span class=p>).</span><span class=n>unwrap</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=n>task_instance_is_done</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>])</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>				</span><span class=k>continue</span><span class=p>;</span><span class=w>
</span><span class=w>			</span><span class=p>}</span><span class=w>
</span><span class=w>			</span><span class=c1>// deducted \\
</span><span class=c1></span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>		</span><span class=c1>// deducted \\
</span><span class=c1></span><span class=w>	</span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>It&rsquo;s already explained in the comment above the function, but let&rsquo;s write it out step-by-step.
The <code>toposort</code> is already here, returning the index for each node in order.
We also create what we will later return, the stage, and the list of downstream tasks of the tasks in the current stage.
Additionally, I added a check at the very beginning of the loop, calling <code>task_instance_is_done()</code> which returns <code>true</code> if the status matches to success or failure.
In that case this node is already a-okay‚úÖ.</p><p>Now we check if the current task is already in the <code>downstream</code> vector.
If it is not, we can directly add it to our <code>stage</code> because we get all results from <code>toposort</code> in order.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>downstream_tasks</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>].</span><span class=n>downstream_tasks</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>if</span><span class=w> </span><span class=n>downstream</span><span class=p>.</span><span class=n>contains</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>].</span><span class=n>task_id</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=c1>// deducted \\
</span><span class=c1></span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=n>stage</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>);</span><span class=w>
</span><span class=w>	</span><span class=n>downstream</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>downstream_tasks</span><span class=p>.</span><span class=n>clone</span><span class=p>());</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>What&rsquo;s missing now is the logic to determine whether something should be added to the current stage, even if it is part of the downstream dependencies.
So let&rsquo;s <code>match</code> over the <code>run_condition</code> of our node.
The important conditions here are</p><ul><li><code>None</code>, execute without caring for dependencies</li><li><code>OneDone</code>, execute when one parent is done</li><li><code>OneSuccess</code>, execute when one parent has succeeded</li><li><code>OneFailed</code>, execute when one parent has failed</li></ul><p>The reason behind this is, that if all parents were done, it should not have been listed in the <code>downstream</code> vector in the first place.
I implemented the logic for all possible cases in the match.
Rust match is exhaustive, although I could&rsquo;ve probably just combined them all with <code>_ => ()</code>.
But I decided it would be nice to have, and I will most likely extend the features of this code later.</p><p>For now, let&rsquo;s dive into the <code>match</code>, and match to <code>None</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>match</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>].</span><span class=n>run_condition</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=n>RunCondition</span>::<span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=n>stage</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>);</span><span class=w>
</span><span class=w>		</span><span class=n>downstream</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>downstream_tasks</span><span class=p>.</span><span class=n>clone</span><span class=p>());</span><span class=w>
</span><span class=w>	</span><span class=p>},</span><span class=w>
</span><span class=w>	</span><span class=c1>// deducted \\
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>Simple enough, we push the current <code>node</code> to the <code>stage</code> and add its <code>downstream_tasks</code> to the <code>downstream</code> vector.
Now the arms for <code>OneDone</code> <code>OneSuccess</code> <code>OneFailed</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>match</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>].</span><span class=n>run_condition</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=n>RunCondition</span>::<span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=n>stage</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>);</span><span class=w>
</span><span class=w>		</span><span class=n>downstream</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>downstream_tasks</span><span class=p>.</span><span class=n>clone</span><span class=p>());</span><span class=w>
</span><span class=w>	</span><span class=p>},</span><span class=w>
</span><span class=w>	</span><span class=n>RunCondition</span>::<span class=n>OneDone</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=n>parent</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>graph</span><span class=p>.</span><span class=n>neighbors_directed</span><span class=p>(</span><span class=n>node</span><span class=p>,</span><span class=w> </span><span class=n>Direction</span>::<span class=n>Incoming</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=n>task_instance_is_done</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>graph</span><span class=p>[</span><span class=n>parent</span><span class=p>])</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>				</span><span class=n>stage</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>);</span><span class=w>
</span><span class=w>				</span><span class=n>downstream</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>downstream_tasks</span><span class=p>.</span><span class=n>clone</span><span class=p>());</span><span class=w>
</span><span class=w>				</span><span class=k>break</span><span class=p>;</span><span class=w>
</span><span class=w>			</span><span class=p>}</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=p>},</span><span class=w>
</span><span class=w>	</span><span class=n>RunCondition</span>::<span class=n>OneSuccess</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=n>parent</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>graph</span><span class=p>.</span><span class=n>neighbors_directed</span><span class=p>(</span><span class=n>node</span><span class=p>,</span><span class=w> </span><span class=n>Direction</span>::<span class=n>Incoming</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=n>matches</span><span class=o>!</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>graph</span><span class=p>[</span><span class=n>parent</span><span class=p>].</span><span class=n>execution_status</span><span class=p>,</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>ExecutionStatus</span>::<span class=n>Success</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>				</span><span class=n>stage</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>);</span><span class=w>
</span><span class=w>				</span><span class=n>downstream</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>downstream_tasks</span><span class=p>.</span><span class=n>clone</span><span class=p>());</span><span class=w>
</span><span class=w>				</span><span class=k>break</span><span class=p>;</span><span class=w>
</span><span class=w>			</span><span class=p>}</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=p>},</span><span class=w>
</span><span class=w>	</span><span class=n>RunCondition</span>::<span class=n>OneFailed</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=n>parent</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>graph</span><span class=p>.</span><span class=n>neighbors_directed</span><span class=p>(</span><span class=n>node</span><span class=p>,</span><span class=w> </span><span class=n>Direction</span>::<span class=n>Incoming</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=n>matches</span><span class=o>!</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>graph</span><span class=p>[</span><span class=n>parent</span><span class=p>].</span><span class=n>execution_status</span><span class=p>,</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>ExecutionStatus</span>::<span class=n>Failed</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>				</span><span class=n>stage</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>);</span><span class=w>
</span><span class=w>				</span><span class=n>downstream</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>downstream_tasks</span><span class=p>.</span><span class=n>clone</span><span class=p>());</span><span class=w>
</span><span class=w>				</span><span class=k>break</span><span class=p>;</span><span class=w>
</span><span class=w>			</span><span class=p>}</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=p>},</span><span class=w>
</span><span class=w>	</span><span class=c1>// deducted \\
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>I deducted the remaining conditions, because as I&rsquo;ve mentioned they are not really relevant as of yet.
Basically the code for every arm is very similiar.
We start of by iterating through the parents by using the <code>neighbors_directed()</code> functions with the <code>Incoming</code> direction.
This means we get an Iterator of indices for the graph for all nodes with edges going towards our current node: the parents.
Then we check if the parent&rsquo;s execution status is meeting our run condition.
If so, we add the <code>node</code> to the <code>stage</code> and its <code>downstream_tasks</code> to the <code>downstream</code>.</p><p>Simple as that, we created the current execution stage.
Finally, we return the result.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>if</span><span class=w> </span><span class=n>stage</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=nb>None</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=nb>Some</span><span class=p>(</span><span class=n>stage</span><span class=p>)</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>By returning <code>None</code> when the vector is empty, we signal the end of the iterator.</p><h2 id=review>Review<a hidden class=anchor aria-hidden=true href=#review>#</a></h2><p>We achieved our goal of implementing a workflow graph, which yields the tasks which are executing or up for execution.
Since I&rsquo;m new to Rust I&rsquo;m not sure if I&rsquo;ve taken the best or fanciest path, so I&rsquo;m open for feedback.
I&rsquo;m also new to writing these kinds of posts, so feedback for this format is also appreciated.</p><p>Now that we have a Dag which we can ask for the next tasks in line, I will spend some more time on the scheduler.
The next post will thus most likely be about the workings of the scheduler and using this implemention of a Dag.</p><p>Also I might come back to this implementation to add more features, refactor with more feedback and knowledge and most definetly add some logging capabilitiesüìù.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://teraku.de/tags/rust/>rust</a></li><li><a href=https://teraku.de/tags/workflow/>workflow</a></li><li><a href=https://teraku.de/tags/graph/>graph</a></li><li><a href=https://teraku.de/tags/flowty/>flowty</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://teraku.de>Teraku's blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.replaceState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>